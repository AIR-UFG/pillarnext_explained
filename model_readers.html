<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Model: readers – pillarnext_explained</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Model: readers – pillarnext_explained">
<meta property="og:description" content="PillarNeXt explained">
<meta property="og:site_name" content="pillarnext_explained">
<meta name="twitter:title" content="Model: readers – pillarnext_explained">
<meta name="twitter:description" content="PillarNeXt explained">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">pillarnext_explained</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./model_readers.html">Model: readers</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">pillarnext_explained</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./dataset.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">dataset</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./build_loader.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">build loader</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./model_utils.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model: utils</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./model_readers.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Model: readers</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./model_backbones.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model: backbones</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./model_necks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model: necks</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#pillar-encoder" id="toc-pillar-encoder" class="nav-link active" data-scroll-target="#pillar-encoder">Pillar Encoder</a>
  <ul class="collapse">
  <li><a href="#pfnlayer" id="toc-pfnlayer" class="nav-link" data-scroll-target="#pfnlayer">PFNLayer</a></li>
  <li><a href="#pillarnet" id="toc-pillarnet" class="nav-link" data-scroll-target="#pillarnet">PillarNet</a></li>
  <li><a href="#pillarfeaturenet" id="toc-pillarfeaturenet" class="nav-link" data-scroll-target="#pillarfeaturenet">PillarFeatureNet</a></li>
  </ul></li>
  <li><a href="#voxel-encoder" id="toc-voxel-encoder" class="nav-link" data-scroll-target="#voxel-encoder">Voxel Encoder</a>
  <ul class="collapse">
  <li><a href="#dynamicvoxelencoder" id="toc-dynamicvoxelencoder" class="nav-link" data-scroll-target="#dynamicvoxelencoder">DynamicVoxelEncoder</a></li>
  <li><a href="#voxelnet" id="toc-voxelnet" class="nav-link" data-scroll-target="#voxelnet">VoxelNet</a></li>
  <li><a href="#voxelfeaturenet" id="toc-voxelfeaturenet" class="nav-link" data-scroll-target="#voxelfeaturenet">VoxelFeatureNet</a></li>
  </ul></li>
  <li><a href="#mvf-enconder" id="toc-mvf-enconder" class="nav-link" data-scroll-target="#mvf-enconder">MVF Enconder</a>
  <ul class="collapse">
  <li><a href="#pointnet" id="toc-pointnet" class="nav-link" data-scroll-target="#pointnet">PointNet</a></li>
  <li><a href="#pillarvoxelnet" id="toc-pillarvoxelnet" class="nav-link" data-scroll-target="#pillarvoxelnet">PillarVoxelNet</a></li>
  <li><a href="#cylindernet" id="toc-cylindernet" class="nav-link" data-scroll-target="#cylindernet">CylinderNet</a></li>
  <li><a href="#singleview" id="toc-singleview" class="nav-link" data-scroll-target="#singleview">SingleView</a></li>
  <li><a href="#mvffeaturenet" id="toc-mvffeaturenet" class="nav-link" data-scroll-target="#mvffeaturenet">MVFFeatureNet</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/AIR-UFG/pillarnext_explained/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Model: readers</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="pillar-encoder" class="level2">
<h2 class="anchored" data-anchor-id="pillar-encoder">Pillar Encoder</h2>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L19" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="pfnlayer" class="level3">
<h3 class="anchored" data-anchor-id="pfnlayer">PFNLayer</h3>
<blockquote class="blockquote">
<pre><code> PFNLayer (in_channels:int, out_channels:int, norm_cfg=None,
           last_layer:bool=False)</code></pre>
</blockquote>
<p><em>Pillar Feature Net Layer. The Pillar Feature Net could be composed of a series of these layers, but the PointPillars paper results only used a single PFNLayer. This layer performs a similar role as second.pytorch.voxelnet.VFELayer.</em></p>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 25%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>in_channels</td>
<td>int</td>
<td></td>
<td>Number of input channels</td>
</tr>
<tr class="even">
<td>out_channels</td>
<td>int</td>
<td></td>
<td>Number of output channels</td>
</tr>
<tr class="odd">
<td>norm_cfg</td>
<td>NoneType</td>
<td>None</td>
<td>Normalization config (not used here, but could be for future extensions)</td>
</tr>
<tr class="even">
<td>last_layer</td>
<td>bool</td>
<td>False</td>
<td>If last_layer, there is no concatenation of features</td>
</tr>
</tbody>
</table>
<div id="cell-4" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PFNLayer(nn.Module):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Pillar Feature Net Layer.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    The Pillar Feature Net could be composed of a series of these layers, but the PointPillars paper results only</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    used a single PFNLayer. This layer performs a similar role as second.pytorch.voxelnet.VFELayer.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                 in_channels: <span class="bu">int</span>,  <span class="co"># Number of input channels</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                 out_channels: <span class="bu">int</span>,  <span class="co"># Number of output channels</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                 norm_cfg<span class="op">=</span><span class="va">None</span>,  <span class="co"># Normalization config (not used here, but could be for future extensions)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                 last_layer: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>  <span class="co"># If last_layer, there is no concatenation of features</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                 ):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.last_vfe <span class="op">=</span> last_layer  <span class="co"># Check if this is the last layer</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.last_vfe:</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            out_channels <span class="op">=</span> out_channels <span class="op">//</span> <span class="dv">2</span>  <span class="co"># If not the last layer, half the output channels</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.units <span class="op">=</span> out_channels</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(in_channels, out_channels, bias<span class="op">=</span><span class="va">False</span>)  <span class="co"># Linear layer to transform inputs</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.norm <span class="op">=</span> nn.BatchNorm1d(out_channels, eps<span class="op">=</span><span class="fl">1e-3</span>, momentum<span class="op">=</span><span class="fl">0.01</span>)  <span class="co"># Batch normalization</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, inputs, unq_inv):</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        torch.backends.cudnn.enabled <span class="op">=</span> <span class="va">False</span>  <span class="co"># Disable cuDNN for compatibility reasons</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.linear(inputs)  <span class="co"># Apply linear transformation</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.norm(x)  <span class="co"># Apply batch normalization</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> F.relu(x)  <span class="co"># Apply ReLU activation</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        torch.backends.cudnn.enabled <span class="op">=</span> <span class="va">True</span>  <span class="co"># Re-enable cuDNN</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># max pooling</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        feat_max <span class="op">=</span> torch_scatter.scatter_max(x, unq_inv, dim<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]  <span class="co"># Perform scatter max pooling</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        x_max <span class="op">=</span> feat_max[unq_inv]  <span class="co"># Gather the max features for each point</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.last_vfe:</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x_max  <span class="co"># If this is the last layer, return the max features</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>            x_concatenated <span class="op">=</span> torch.cat([x, x_max], dim<span class="op">=</span><span class="dv">1</span>)  <span class="co"># Otherwise, concatenate the original and max features</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x_concatenated  <span class="co"># Return the concatenated features</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <code>PFNLayer Class</code> class implements a layer of the Pillar Feature Net. It includes a linear transformation, batch normalization, and ReLU activation. It also performs scatter max pooling to extract the maximum features per pillar. The PFNLayer class essentially extracts features from point clouds.</p>
<section id="differences-from-pytorch-standard-implementations" class="level4">
<h4 class="anchored" data-anchor-id="differences-from-pytorch-standard-implementations">Differences from PyTorch Standard Implementations</h4>
<p>This class extends basic PyTorch components to perform specific operations for 3D point cloud data. The main differences include:</p>
<ul>
<li><p><strong>Scatter Operations</strong>: Instead of using standard pooling operations like <code>max pooling</code>, the class employs <code>torch_scatter.scatter_max</code>, which is crucial for handling sparse point cloud data. PyTorch does not natively support this type of scatter operation.</p></li>
<li><p><strong>Custom Feature Concatenation</strong>: The concatenation of original and max-pooled features, dependent on whether the layer is the last in the network, is a custom behavior not found in standard PyTorch layers.</p></li>
</ul>
</section>
<section id="abstractions-provided-by-pfnlayer" class="level4">
<h4 class="anchored" data-anchor-id="abstractions-provided-by-pfnlayer">Abstractions Provided by PFNLayer</h4>
<ul>
<li><p><strong>Pooling in Point Clouds</strong>: PFNLayer abstracts the complexity of performing scatter-based max pooling, which is not straightforward in PyTorch’s standard API.</p></li>
<li><p><strong>Conditional Feature Concatenation</strong>: It abstracts the logic of deciding whether or not to concatenate features based on whether it’s the last layer.</p></li>
<li><p><strong>Custom Batch Normalization</strong>: The use of <code>nn.BatchNorm1d</code> with a custom <code>eps</code> and <code>momentum</code> is abstracted, so the user doesn’t need to handle these details directly.</p></li>
</ul>
</section>
<section id="limitations-compared-to-a-direct-pytorch-implementation" class="level4">
<h4 class="anchored" data-anchor-id="limitations-compared-to-a-direct-pytorch-implementation">Limitations Compared to a Direct PyTorch Implementation</h4>
<ul>
<li><p><strong>Limited Flexibility</strong>: The class is specialized for the PointPillars architecture. A more direct PyTorch implementation might allow for greater flexibility in terms of pooling strategies, feature transformations, and layer configurations.</p></li>
<li><p><strong>Hardcoded Operations</strong>: The specific operations (like the choice of <code>ReLU</code> activation, <code>BatchNorm1d</code>, and <code>scatter_max</code>) are hardcoded. A more direct PyTorch approach would allow these choices to be more easily customized or replaced with alternatives.</p></li>
</ul>
<div id="cell-6" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Example data</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> torch.rand(<span class="dv">10</span>, <span class="dv">64</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>unq_inv <span class="op">=</span> torch.randint(<span class="dv">0</span>, <span class="dv">2</span>, (<span class="dv">10</span>,))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Input shape: </span><span class="sc">{</span>inputs<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Unique inverse shape: </span><span class="sc">{</span>unq_inv<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize PFNLayer</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>pfn_layer <span class="op">=</span> PFNLayer(in_channels<span class="op">=</span><span class="dv">64</span>, out_channels<span class="op">=</span><span class="dv">128</span>, last_layer<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> pfn_layer(inputs, unq_inv)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Output shape: </span><span class="sc">{</span>output<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot input features and output features</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].imshow(inputs.numpy(), aspect<span class="op">=</span><span class="st">'auto'</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_title(<span class="st">'Input Features'</span>)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">'Point Index'</span>)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].imshow(output.detach().numpy(), aspect<span class="op">=</span><span class="st">'auto'</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_title(<span class="st">'Output Features'</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_ylabel(<span class="st">'Point Index'</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: torch.Size([10, 64])
Unique inverse shape: torch.Size([10])
Output shape: torch.Size([10, 128])</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_model_readers_files/figure-html/cell-4-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L58" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
</section>
<section id="pillarnet" class="level3">
<h3 class="anchored" data-anchor-id="pillarnet">PillarNet</h3>
<blockquote class="blockquote">
<pre><code> PillarNet (num_input_features:int, voxel_size:list, pc_range:list)</code></pre>
</blockquote>
<p>*PillarNet. The network performs dynamic pillar scatter that convert point cloud into pillar representation and extract pillar features</p>
<p>Reference: PointPillars: Fast Encoders for Object Detection from Point Clouds (https://arxiv.org/abs/1812.05784) End-to-End Multi-View Fusion for 3D Object Detection in LiDAR Point Clouds (https://arxiv.org/abs/1910.06528)*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 38%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>num_input_features</td>
<td>int</td>
<td>Number of input features</td>
</tr>
<tr class="even">
<td>voxel_size</td>
<td>list</td>
<td>A list that defines the size of the voxels (grids) in the x and y dimensions.</td>
</tr>
<tr class="odd">
<td>pc_range</td>
<td>list</td>
<td>A list defining the range of the point cloud data in the x and y dimensions. This is used to filter and normalize the point cloud data. Only utilize x and y min</td>
</tr>
</tbody>
</table>
<div id="cell-8" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PillarNet(nn.Module):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    PillarNet.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    The network performs dynamic pillar scatter that convert point cloud into pillar representation</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    and extract pillar features</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Reference:</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">    PointPillars: Fast Encoders for Object Detection from Point Clouds (https://arxiv.org/abs/1812.05784)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">    End-to-End Multi-View Fusion for 3D Object Detection in LiDAR Point Clouds (https://arxiv.org/abs/1910.06528)</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                 num_input_features: <span class="bu">int</span>, <span class="co"># Number of input features</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>                 voxel_size: <span class="bu">list</span>, <span class="co"># A list that defines the size of the voxels (grids) in the x and y dimensions.</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>                 pc_range: <span class="bu">list</span>, <span class="co"># A list defining the range of the point cloud data in the x and y dimensions. This is used to filter and normalize the point cloud data. Only utilize x and y min</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>                 ):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_size <span class="op">=</span> np.array(voxel_size)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pc_range <span class="op">=</span> np.array(pc_range)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>,</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                points: torch.Tensor <span class="co"># Points in LiDAR coordinate, shape: (N, d), format: batch_id, x, y, z, feat1, ...</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        device <span class="op">=</span> points.device</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        dtype <span class="op">=</span> points.dtype</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># discard out of range points</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> (<span class="va">self</span>.pc_range[<span class="dv">3</span>:] <span class="op">-</span> <span class="va">self</span>.pc_range[:<span class="dv">3</span>]</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>                     )<span class="op">/</span><span class="va">self</span>.voxel_size  <span class="co"># x,  y, z</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> np.<span class="bu">round</span>(grid_size, <span class="dv">0</span>, grid_size).astype(np.int64)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        voxel_size <span class="op">=</span> torch.from_numpy(</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.voxel_size).type_as(points).to(device)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        pc_range <span class="op">=</span> torch.from_numpy(<span class="va">self</span>.pc_range).type_as(points).to(device)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> (</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>            points[:, <span class="dv">1</span>:<span class="dv">4</span>] <span class="op">-</span> pc_range[:<span class="dv">3</span>].view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)) <span class="op">/</span> voxel_size.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)   <span class="co"># x, y, z</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> <span class="bu">reduce</span>(torch.logical_and, (points_coords[:, <span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">0</span>,</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">0</span>] <span class="op">&lt;</span> grid_size[<span class="dv">0</span>],</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">0</span>,</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">1</span>] <span class="op">&lt;</span> grid_size[<span class="dv">1</span>]))</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        points <span class="op">=</span> points[mask]</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> points_coords[mask]</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> points_coords.<span class="bu">long</span>()</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        batch_idx <span class="op">=</span> points[:, <span class="dv">0</span>:<span class="dv">1</span>].<span class="bu">long</span>()</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>        points_index <span class="op">=</span> torch.cat((batch_idx, points_coords[:, :<span class="dv">2</span>]), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>        unq, unq_inv <span class="op">=</span> torch.unique(points_index, return_inverse<span class="op">=</span><span class="va">True</span>, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>        unq <span class="op">=</span> unq.<span class="bu">int</span>()</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>        points_mean_scatter <span class="op">=</span> torch_scatter.scatter_mean(</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>            points[:, <span class="dv">1</span>:<span class="dv">4</span>], unq_inv, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>        f_cluster <span class="op">=</span> points[:, <span class="dv">1</span>:<span class="dv">4</span>] <span class="op">-</span> points_mean_scatter[unq_inv]</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find distance of x, y, and z from pillar center</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>        f_center <span class="op">=</span> points[:, <span class="dv">1</span>:<span class="dv">3</span>] <span class="op">-</span> (points_coords[:, :<span class="dv">2</span>].to(dtype) <span class="op">*</span> voxel_size[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>                                     voxel_size[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>) <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> pc_range[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>))</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine together feature decorations</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> torch.cat([points[:, <span class="dv">1</span>:], f_cluster, f_center], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> features, unq[:, [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>]], unq_inv, grid_size[[<span class="dv">1</span>, <span class="dv">0</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarnet"><code>PillarNet</code></a> class is a neural network module designed for converting LiDAR point clouds into a structured pillar representation. It is based on the concepts introduced in papers such as <a href="https://arxiv.org/abs/1812.05784">PointPillars: Fast Encoders for Object Detection from Point Clouds</a> and <a href="https://arxiv.org/abs/1910.06528">End-to-End Multi-View Fusion for 3D Object Detection in LiDAR Point Clouds</a>. This network performs a dynamic pillar scatter operation, which helps in efficiently extracting pillar features from unstructured point cloud data.</p>
<section id="core-functionality" class="level4">
<h4 class="anchored" data-anchor-id="core-functionality">Core Functionality</h4>
<ol type="1">
<li><strong>Forward Method</strong>:
<ul>
<li><strong>Point Filtering</strong>: The input points are filtered based on the specified <code>pc_range</code> to discard points that are outside the defined range.</li>
<li><strong>Grid Size Calculation</strong>: The grid size is computed based on the <code>voxel_size</code> and <code>pc_range</code>, which determines the resolution of the voxelization.</li>
<li><strong>Point Coordinates Normalization</strong>: The point coordinates are normalized with respect to the voxel size and point cloud range, converting the continuous coordinates into discrete voxel indices.</li>
<li><strong>Point Clustering</strong>: The points are clustered into pillars based on their voxel indices.</li>
<li><strong>Feature Decoration</strong>: Additional features are calculated, including:
<ul>
<li><code>f_cluster</code>: The distance of each point from the mean of its cluster (pillar).</li>
<li><code>f_center</code>: The distance of each point from the center of its respective voxel.</li>
</ul></li>
<li><strong>Feature Aggregation</strong>: The original point features, along with the newly computed features (<code>f_cluster</code> and <code>f_center</code>), are concatenated to form the final feature set for each point.</li>
<li><strong>Return Values</strong>: The method returns the final point features, the unique pillar indices, the inverse indices used for aggregation, and the grid size.</li>
</ul></li>
</ol>
</section>
<section id="differences" class="level4">
<h4 class="anchored" data-anchor-id="differences">Differences</h4>
<ol type="1">
<li><strong>Abstraction of Point Cloud Operations</strong>:
<ul>
<li>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarnet"><code>PillarNet</code></a> class abstracts the voxelization and feature extraction process, which would otherwise require manual implementation using basic PyTorch operations. It provides a higher-level interface to work with point cloud data, simplifying the process of converting point clouds into pillar-based representations.</li>
</ul></li>
<li><strong>Integration of Advanced Operations</strong>:
<ul>
<li>Operations like <code>torch_scatter.scatter_mean</code> are used for efficiently computing cluster mean features. These operations are not directly available in standard PyTorch and require the use of external libraries like <code>torch_scatter</code>.</li>
</ul></li>
<li><strong>Grid Management</strong>:
<ul>
<li>The class handles the computation of grid size and point normalization internally, which would otherwise require manual calculation and management in a more direct implementation.</li>
</ul></li>
</ol>
</section>
<section id="limitations" class="level4">
<h4 class="anchored" data-anchor-id="limitations">Limitations</h4>
<ol type="1">
<li><strong>Flexibility</strong>:
<ul>
<li>While <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarnet"><code>PillarNet</code></a> provides a streamlined approach to pillar feature extraction, it may lack the flexibility needed for more customized operations or for handling point cloud data in formats that differ from the assumptions made in the class.</li>
</ul></li>
<li><strong>Limited Customization</strong>:
<ul>
<li>The class is designed for a specific type of pillar-based representation. Users who require different types of voxelization or feature extraction strategies may find it limiting and may need to modify or extend the class, which could be more cumbersome than implementing a direct approach from scratch.</li>
</ul></li>
</ol>
<div id="cell-10" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a sample point cloud with shape (N, d)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Here, d includes batch_id, x, y, z, and some additional features (e.g., intensity)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> torch.tensor([</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="fl">1.0</span>, <span class="fl">2.0</span>, <span class="fl">3.0</span>, <span class="fl">0.5</span>],</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="fl">2.5</span>, <span class="fl">3.5</span>, <span class="fl">4.5</span>, <span class="fl">0.6</span>],</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="fl">5.0</span>, <span class="fl">6.0</span>, <span class="fl">7.0</span>, <span class="fl">0.7</span>],</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="fl">8.0</span>, <span class="fl">9.0</span>, <span class="fl">10.0</span>, <span class="fl">0.8</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>], dtype<span class="op">=</span>torch.float32)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the number of input features (excluding batch_id, x, y, z)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>num_input_features <span class="op">=</span> points.shape[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Define voxel size (x_size, y_size, z_size)</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Define point cloud range (x_min, y_min, z_min, x_max, y_max, z_max)</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>pc_range <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">10</span>]</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an instance of PillarNet</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>pillar_net <span class="op">=</span> PillarNet(num_input_features, voxel_size, pc_range)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass with the sample points</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>features, unique_voxel_indices, inverse_indices, grid_size <span class="op">=</span> pillar_net(points)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Features:"</span>, features)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique Voxel Indices:"</span>, unique_voxel_indices)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Inverse Indices:"</span>, inverse_indices)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Grid Size:"</span>, grid_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Features: tensor([[ 1.0000,  2.0000,  3.0000,  0.5000,  0.0000,  0.0000,  0.0000, -0.2500,
         -0.2500],
        [ 2.5000,  3.5000,  4.5000,  0.6000,  0.0000,  0.0000,  0.0000, -0.2500,
         -0.2500],
        [ 5.0000,  6.0000,  7.0000,  0.7000,  0.0000,  0.0000,  0.0000, -0.2500,
         -0.2500],
        [ 8.0000,  9.0000, 10.0000,  0.8000,  0.0000,  0.0000,  0.0000, -0.2500,
         -0.2500]])
Unique Voxel Indices: tensor([[ 0,  4,  2],
        [ 0,  7,  5],
        [ 1, 12, 10],
        [ 1, 18, 16]], dtype=torch.int32)
Inverse Indices: tensor([0, 1, 2, 3])
Grid Size: [20 20]</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L127" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
</section>
<section id="pillarfeaturenet" class="level3">
<h3 class="anchored" data-anchor-id="pillarfeaturenet">PillarFeatureNet</h3>
<blockquote class="blockquote">
<pre><code> PillarFeatureNet (num_input_features:int, num_filters:list,
                   voxel_size:list, pc_range:list, norm_cfg:None)</code></pre>
</blockquote>
<p><em>Pillar Feature Net. The network prepares the pillar features and performs forward pass through PFNLayers. This net performs a similar role to SECOND’s second.pytorch.voxelnet.VoxelFeatureExtractor.</em></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>num_input_features</td>
<td>int</td>
<td>Number of input features</td>
</tr>
<tr class="even">
<td>num_filters</td>
<td>list</td>
<td>Number of features in each of the N PFNLayers</td>
</tr>
<tr class="odd">
<td>voxel_size</td>
<td>list</td>
<td>Size of voxels, only utilize x and y size</td>
</tr>
<tr class="even">
<td>pc_range</td>
<td>list</td>
<td>Point cloud range, only utilize x and y min</td>
</tr>
<tr class="odd">
<td>norm_cfg</td>
<td>None</td>
<td>Normalization config</td>
</tr>
</tbody>
</table>
<div id="cell-12" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PillarFeatureNet(nn.Module):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Pillar Feature Net.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">    The network prepares the pillar features and performs forward pass through PFNLayers. This net performs a</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">    similar role to SECOND's second.pytorch.voxelnet.VoxelFeatureExtractor.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        num_input_features: <span class="bu">int</span>, <span class="co"># Number of input features</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        num_filters: <span class="bu">list</span>, <span class="co"># Number of features in each of the N PFNLayers</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        voxel_size: <span class="bu">list</span>, <span class="co"># Size of voxels, only utilize x and y size</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        pc_range: <span class="bu">list</span>, <span class="co"># Point cloud range, only utilize x and y min</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        norm_cfg:<span class="va">None</span>, <span class="co"># Normalization config</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="bu">len</span>(num_filters) <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        num_input_features <span class="op">+=</span> <span class="dv">5</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create PillarFeatureNet layers</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        num_filters <span class="op">=</span> [num_input_features] <span class="op">+</span> <span class="bu">list</span>(num_filters)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        pfn_layers <span class="op">=</span> []</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(num_filters) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>            in_filters <span class="op">=</span> num_filters[i]</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            out_filters <span class="op">=</span> num_filters[i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(num_filters) <span class="op">-</span> <span class="dv">2</span>:</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>                last_layer <span class="op">=</span> <span class="va">False</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>                last_layer <span class="op">=</span> <span class="va">True</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>            pfn_layers.append(</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>                PFNLayer(</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>                    in_filters, out_filters, norm_cfg<span class="op">=</span>norm_cfg, last_layer<span class="op">=</span>last_layer</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pfn_layers <span class="op">=</span> nn.ModuleList(pfn_layers)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.feature_output_dim <span class="op">=</span> num_filters[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_size <span class="op">=</span> np.array(voxel_size)</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pc_range <span class="op">=</span> np.array(pc_range)</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxelization <span class="op">=</span> PillarNet(num_input_features, voxel_size, pc_range)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, points):</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>        features, coords, unq_inv, grid_size <span class="op">=</span> <span class="va">self</span>.voxelization(points)</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Forward pass through PFNLayers</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pfn <span class="kw">in</span> <span class="va">self</span>.pfn_layers:</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>            features <span class="op">=</span> pfn(features, unq_inv)  <span class="co"># num_points, dim_feat</span></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>        feat_max <span class="op">=</span> torch_scatter.scatter_max(features, unq_inv, dim<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> feat_max, coords, grid_size</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarfeaturenet"><code>PillarFeatureNet</code></a> class is designed for preparing pillar features from the point cloud data, used in 3D object detection tasks in LiDAR-based perception systems. This network handles the transformation of raw point cloud data into a more structured and feature-rich representation, which will be essential for further processing in the object detection.</p>
<section id="funcionality" class="level4">
<h4 class="anchored" data-anchor-id="funcionality">Funcionality</h4>
<ol type="1">
<li><strong>Initialization (<code>__init__</code> method):</strong>
<ul>
<li><strong>Input Features Augmentation:</strong> The class initializes by augmenting the input features with additional spatial information, increasing the dimensionality by 5 (which might include features like the relative position of points within a pillar, etc.).</li>
<li><strong>Layer Creation:</strong> It then creates a sequence of layers, <code>PFNLayers</code>, which perform the feature extraction. The number of layers and their configuration are determined by the <code>num_filters</code> parameter.</li>
<li><strong>Voxelization:</strong> The class initializes the voxelization process, converting the raw point cloud data into a voxel grid with specified <code>voxel_size</code> and within a specified <code>pc_range</code> (point cloud range). This voxelization is essential for handling irregular point clouds by grouping points into a regular grid structure, called “pillars.”</li>
</ul></li>
<li><strong>Forward Pass (<code>forward</code> method):</strong>
<ul>
<li><strong>Voxelization:</strong> The input point cloud is first voxelized, where the points are grouped into pillars, and features are extracted.</li>
<li><strong>PFN Layers:</strong> The extracted features are passed through the <code>PFNLayers</code>, where each layer performs a certain amount of processing. These layers typically involve operations like PointNet-style feature learning.</li>
<li><strong>Max Pooling:</strong> Finally, the features are aggregated using a max-pooling operation (<code>torch_scatter.scatter_max</code>), which pools the features across the points in each pillar to get a fixed-size feature vector for each pillar.</li>
</ul></li>
</ol>
</section>
<section id="abstraction" class="level4">
<h4 class="anchored" data-anchor-id="abstraction">Abstraction</h4>
<p>This class abstracts several operations that would require more manual implementation in pure PyTorch. For instance, voxelization and the subsequent grouping of points into pillars are handled internally by the <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarnet"><code>PillarNet</code></a> class.</p>
<p>The abstraction can reduce flexibility. If you need to tweak certain aspects of the feature extraction or voxelization process, this might be harder to do compared to a more manual approach where every operation is explicit.</p>
<div id="cell-14" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define input parameters for PillarFeatureNet</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Mock values for demonstration purposes</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>num_input_features <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>num_filters <span class="op">=</span> [<span class="dv">64</span>, <span class="dv">128</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> [<span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="fl">0.2</span>]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>pc_range <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">50</span>, <span class="dv">50</span>, <span class="dv">50</span>]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>norm_cfg <span class="op">=</span> <span class="va">None</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Instantiate the PillarFeatureNet</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>pillar_feature_net <span class="op">=</span> PillarFeatureNet(</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    num_input_features<span class="op">=</span>num_input_features,</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    num_filters<span class="op">=</span>num_filters,</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    voxel_size<span class="op">=</span>voxel_size,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    pc_range<span class="op">=</span>pc_range,</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    norm_cfg<span class="op">=</span>norm_cfg</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Create some dummy input points</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Each point might have x, y, z, intensity, etc.</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>num_points <span class="op">=</span> <span class="dv">100</span>  <span class="co"># Number of points in the point cloud</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> torch.rand(num_points, num_input_features <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># Random points (x, y, z, intensity)</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Run a forward pass</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>feat_max, coords, grid_size <span class="op">=</span> pillar_feature_net(points)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the outputs</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Max Features:</span><span class="ch">\n</span><span class="st">"</span>, feat_max)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Voxel Coordinates:</span><span class="ch">\n</span><span class="st">"</span>, coords)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Grid Size:</span><span class="ch">\n</span><span class="st">"</span>, grid_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Max Features:
 tensor([[0.0000, 1.9903, 1.5468,  ..., 0.1351, 1.5962, 1.8613],
        [0.0953, 0.8951, 0.5835,  ..., 0.3777, 0.4148, 1.1723],
        [0.0000, 0.0000, 0.0628,  ..., 0.0000, 0.0000, 0.0000],
        ...,
        [0.0000, 0.6913, 0.4461,  ..., 1.3929, 0.0906, 1.3596],
        [0.0000, 0.0000, 0.0000,  ..., 0.1496, 0.0000, 0.0000],
        [0.0000, 0.0000, 0.0000,  ..., 1.5835, 0.0000, 0.0030]],
       grad_fn=&lt;CppNode&lt;ScatterMax&gt;&gt;)
Voxel Coordinates:
 tensor([[0, 0, 0],
        [0, 1, 0],
        [0, 2, 0],
        [0, 3, 0],
        [0, 4, 0],
        [0, 0, 1],
        [0, 1, 1],
        [0, 2, 1],
        [0, 3, 1],
        [0, 4, 1],
        [0, 0, 2],
        [0, 1, 2],
        [0, 2, 2],
        [0, 3, 2],
        [0, 4, 2],
        [0, 0, 3],
        [0, 1, 3],
        [0, 2, 3],
        [0, 3, 3],
        [0, 4, 3],
        [0, 0, 4],
        [0, 1, 4],
        [0, 2, 4],
        [0, 3, 4],
        [0, 4, 4]], dtype=torch.int32)
Grid Size:
 [250 250]</code></pre>
</div>
</div>
<div id="cell-15" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create some dummy input points</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>num_points <span class="op">=</span> <span class="dv">100</span>  <span class="co"># Number of points in the point cloud</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> torch.rand(num_points, num_input_features <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># Random points (x, y, z, intensity)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the input using matplotlib</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot point cloud coordinates</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>ax.scatter(points[:, <span class="dv">0</span>].numpy(), points[:, <span class="dv">1</span>].numpy(), points[:, <span class="dv">2</span>].numpy(), c<span class="op">=</span><span class="st">'r'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Label axes</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'X'</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Y'</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>ax.set_zlabel(<span class="st">'Z'</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Title</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Point Cloud Coordinates'</span>)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_model_readers_files/figure-html/cell-11-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-16" class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the output using matplotlib</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot voxel coordinates</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>ax.scatter(coords[:, <span class="dv">0</span>].numpy(), coords[:, <span class="dv">1</span>].numpy(), coords[:, <span class="dv">2</span>].numpy(), c<span class="op">=</span><span class="st">'b'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Label axes</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'X'</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Y'</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>ax.set_zlabel(<span class="st">'Z'</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Title</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">'Voxel Coordinates'</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_model_readers_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="voxel-encoder" class="level2">
<h2 class="anchored" data-anchor-id="voxel-encoder">Voxel Encoder</h2>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L181" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="dynamicvoxelencoder" class="level3">
<h3 class="anchored" data-anchor-id="dynamicvoxelencoder">DynamicVoxelEncoder</h3>
<blockquote class="blockquote">
<pre><code> DynamicVoxelEncoder ()</code></pre>
</blockquote>
<p><em>Dynamic version of VoxelFeatureExtractorV3</em></p>
<div id="cell-19" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DynamicVoxelEncoder(nn.Module):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Dynamic version of VoxelFeatureExtractorV3</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>(DynamicVoxelEncoder, <span class="va">self</span>).<span class="fu">__init__</span>()</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, inputs, unq_inv):</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> torch_scatter.scatter_mean(inputs, unq_inv, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> features</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#dynamicvoxelencoder"><code>DynamicVoxelEncoder</code></a> class is a module that serves as a custom feature extractor for voxel-based data, utilizing dynamic computations to process input features.</p>
<p>The method performs a scatter operation using the <code>torch_scatter.scatter_mean</code> function, which computes the mean of features that belong to the same group, as indicated by the <code>unq_inv</code> tensor. The result is a tensor of aggregated features, where each feature corresponds to a unique group.</p>
<p>This design makes the <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#dynamicvoxelencoder"><code>DynamicVoxelEncoder</code></a> easy to integrate into larger architectures that require voxel-based feature extraction, such as 3D object detection networks.</p>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L195" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="voxelnet" class="level3">
<h3 class="anchored" data-anchor-id="voxelnet">VoxelNet</h3>
<blockquote class="blockquote">
<pre><code> VoxelNet (voxel_size, pc_range)</code></pre>
</blockquote>
<p>*Dynamic voxelization for point clouds</p>
<p>This class performs dynamic voxelization on input point clouds. It converts point coordinates into voxel grid coordinates and removes points that fall outside the specified range.*</p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>voxel_size</td>
<td>The size of each voxel in the grid. It is expected to be a 3-element list or array that defines the size of the voxel in the x, y, and z dimensions.</td>
</tr>
<tr class="even">
<td>pc_range</td>
<td>The range of the point cloud. It’s a 6-element list or array that specifies the minimum and maximum bounds in the x, y, and z dimensions.</td>
</tr>
</tbody>
</table>
<div id="cell-22" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VoxelNet(nn.Module):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Dynamic voxelization for point clouds</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">    This class performs dynamic voxelization on input point clouds.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">    It converts point coordinates into voxel grid coordinates and removes points that fall outside the specified range.</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                voxel_size, <span class="co"># The size of each voxel in the grid. It is expected to be a 3-element list or array that defines the size of the voxel in the x, y, and z dimensions.</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                pc_range <span class="co"># The range of the point cloud. It's a 6-element list or array that specifies the minimum and maximum bounds in the x, y, and z dimensions.</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_size <span class="op">=</span> np.array(voxel_size)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pc_range <span class="op">=</span> np.array(pc_range)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, points):</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="co">        points: Tensor: (N, d), batch_id, x, y, z, ...</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        device <span class="op">=</span> points.device</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># voxel range of x, y, z</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> (<span class="va">self</span>.pc_range[<span class="dv">3</span>:] <span class="op">-</span> <span class="va">self</span>.pc_range[:<span class="dv">3</span>]) <span class="op">/</span> <span class="va">self</span>.voxel_size</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> np.<span class="bu">round</span>(grid_size, <span class="dv">0</span>, grid_size).astype(np.int64)</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        voxel_size <span class="op">=</span> torch.from_numpy(</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.voxel_size).type_as(points).to(device)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        pc_range <span class="op">=</span> torch.from_numpy(<span class="va">self</span>.pc_range).type_as(points).to(device)</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> (</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>            points[:, <span class="dv">1</span>:<span class="dv">4</span>] <span class="op">-</span> pc_range[:<span class="dv">3</span>].view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)) <span class="op">/</span> voxel_size.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)  <span class="co"># x, y, z</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> <span class="bu">reduce</span>(torch.logical_and, (points_coords[:, <span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">0</span>,</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">0</span>] <span class="op">&lt;</span> grid_size[<span class="dv">0</span>],</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">0</span>,</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">1</span>] <span class="op">&lt;</span> grid_size[<span class="dv">1</span>],</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">2</span>] <span class="op">&gt;=</span> <span class="dv">0</span>,</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>                                          points_coords[:, <span class="dv">2</span>] <span class="op">&lt;</span> grid_size[<span class="dv">2</span>]))  <span class="co"># remove the points out of range</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>        points <span class="op">=</span> points[mask]</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> points_coords[mask]</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> points_coords.<span class="bu">long</span>()</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>        batch_idx <span class="op">=</span> points[:, <span class="dv">0</span>:<span class="dv">1</span>].<span class="bu">long</span>()</span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>        point_index <span class="op">=</span> torch.cat((batch_idx, points_coords), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>        unq, unq_inv <span class="op">=</span> torch.unique(point_index, return_inverse<span class="op">=</span><span class="va">True</span>, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>        unq <span class="op">=</span> unq.<span class="bu">int</span>()</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> points[:, <span class="dv">1</span>:]</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> features, unq[:, [<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]], unq_inv, grid_size[[<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#voxelnet"><code>VoxelNet</code></a> class is designed for performing dynamic voxelization on 3D point clouds. Voxelization is a process where a 3D space is divided into a grid of equally sized cubes (voxels), and points from the point cloud are assigned to these voxels based on their spatial coordinates.</p>
<p>Here’s a breakdown of the core functionality of the <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#voxelnet"><code>VoxelNet</code></a> class:</p>
<ul>
<li><strong>Forward Method:</strong>
<ul>
<li>The <code>forward</code> method takes as input a tensor of points. This tensor has the shape <code>(N, d)</code> where <code>N</code> is the number of points and <code>d</code> is the number of features per point. The first feature is the <code>batch_id</code>, and the next three are the coordinates <code>x, y, z</code>. Additional features can be present as well.</li>
<li>The method calculates the size of the voxel grid (<code>grid_size</code>) by dividing the range of the point cloud by the voxel size.</li>
<li>It then computes the voxel grid coordinates (<code>points_coords</code>) for each point by subtracting the minimum point cloud range and dividing by the voxel size.</li>
<li>Points that fall outside the specified range (outside the grid) are filtered out using a mask.</li>
<li>The remaining points and their corresponding voxel coordinates are then converted to integer indices.</li>
<li>The method creates a unique index (<code>point_index</code>) for each point using its <code>batch_id</code> and voxel grid coordinates.</li>
<li>It finds unique voxel indices and returns the following:
<ul>
<li><code>features</code>: The features of the points that remain after filtering.</li>
<li><code>unq</code>: The unique voxel indices corresponding to the unique points.</li>
<li><code>unq_inv</code>: The inverse of the unique voxel indices, mapping back to the original point indices.</li>
<li><code>grid_size</code>: The size of the voxel grid.</li>
</ul></li>
</ul></li>
</ul>
<div id="cell-24" class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an instance of VoxelNet</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> [<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>pc_range <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">10</span>]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>voxel_net <span class="op">=</span> VoxelNet(voxel_size, pc_range)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic point cloud data</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>num_points <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> torch.cat((</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    torch.zeros(num_points, <span class="dv">1</span>),  <span class="co"># batch_id</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    torch.rand(num_points, <span class="dv">3</span>) <span class="op">*</span> <span class="dv">10</span>  <span class="co"># x, y, z</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>features, voxel_coords, unq_inv, grid_size <span class="op">=</span> voxel_net(points)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Print input and output</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Input Points:"</span>)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(points)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Features:"</span>)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(features)</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Voxel Coordinates:"</span>)</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(voxel_coords)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Unique Inverse Indices:"</span>)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(unq_inv)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Grid Size:"</span>)</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(grid_size)</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Visual demonstration using matplotlib</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot original and voxelized points</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>ax.scatter(points[:, <span class="dv">1</span>], points[:, <span class="dv">2</span>], points[:, <span class="dv">3</span>], c<span class="op">=</span><span class="st">'r'</span>, marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">'Original Points'</span>)</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert voxel coordinates to real world coordinates</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span>])</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>pc_range_min <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>real_coords <span class="op">=</span> voxel_coords[:, <span class="dv">1</span>:<span class="dv">4</span>].numpy() <span class="op">*</span> voxel_size <span class="op">+</span> pc_range_min</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>ax.scatter(real_coords[:, <span class="dv">0</span>], real_coords[:, <span class="dv">1</span>], real_coords[:, <span class="dv">2</span>], c<span class="op">=</span><span class="st">'b'</span>, marker<span class="op">=</span><span class="st">'^'</span>, label<span class="op">=</span><span class="st">'Voxelized Points'</span>)</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">'X'</span>)</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">'Y'</span>)</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>ax.set_zlabel(<span class="st">'Z'</span>)</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Voxelization of Point Cloud'</span>)</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input Points:
tensor([[0.0000, 5.1454, 2.3374, 9.9073],
        [0.0000, 8.4996, 3.2674, 0.0379],
        [0.0000, 0.7200, 9.5793, 4.5018],
        [0.0000, 2.4532, 3.3480, 0.9841],
        [0.0000, 5.1391, 0.7281, 4.1405],
        [0.0000, 9.7150, 0.4090, 0.0740],
        [0.0000, 8.9659, 8.5211, 5.7163],
        [0.0000, 4.9131, 7.7118, 0.5395],
        [0.0000, 5.2191, 0.7674, 2.3421],
        [0.0000, 2.7364, 1.3320, 4.8849]])

Features:
tensor([[5.1454, 2.3374, 9.9073],
        [8.4996, 3.2674, 0.0379],
        [0.7200, 9.5793, 4.5018],
        [2.4532, 3.3480, 0.9841],
        [5.1391, 0.7281, 4.1405],
        [9.7150, 0.4090, 0.0740],
        [8.9659, 8.5211, 5.7163],
        [4.9131, 7.7118, 0.5395],
        [5.2191, 0.7674, 2.3421],
        [2.7364, 1.3320, 4.8849]])

Voxel Coordinates:
tensor([[ 0,  9, 19,  1],
        [ 0,  1,  6,  4],
        [ 0,  9,  2,  5],
        [ 0,  1, 15,  9],
        [ 0,  4,  1, 10],
        [ 0,  8,  1, 10],
        [ 0, 19,  4, 10],
        [ 0,  0,  6, 16],
        [ 0, 11, 17, 17],
        [ 0,  0,  0, 19]], dtype=torch.int32)

Unique Inverse Indices:
tensor([6, 7, 0, 1, 5, 9, 8, 3, 4, 2])

Grid Size:
[20 20 20]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_model_readers_files/figure-html/cell-17-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L250" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="voxelfeaturenet" class="level3">
<h3 class="anchored" data-anchor-id="voxelfeaturenet">VoxelFeatureNet</h3>
<blockquote class="blockquote">
<pre><code> VoxelFeatureNet (voxel_size, pc_range)</code></pre>
</blockquote>
<p><em>This class performs dynamic voxelization of point clouds and then encodes the voxel features using DynamicVoxelEncoder.</em></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>voxel_size</td>
<td>size of voxel</td>
</tr>
<tr class="even">
<td>pc_range</td>
<td>point cloud range</td>
</tr>
</tbody>
</table>
<div id="cell-26" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VoxelFeatureNet(nn.Module):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">    This class performs dynamic voxelization of point clouds and then encodes the voxel features using DynamicVoxelEncoder.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>                voxel_size, <span class="co"># size of voxel</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>                pc_range <span class="co"># point cloud range</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxelization <span class="op">=</span> VoxelNet(voxel_size, pc_range)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_encoder <span class="op">=</span> DynamicVoxelEncoder()</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, points):</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        features, coords, unq_inv, grid_size <span class="op">=</span> <span class="va">self</span>.voxelization(points)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> <span class="va">self</span>.voxel_encoder(features, unq_inv)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> features, coords, grid_size</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#voxelfeaturenet"><code>VoxelFeatureNet</code></a> class is designed to perform dynamic voxelization and then encode the voxelized features. It integrates the functionality of the <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#voxelnet"><code>VoxelNet</code></a> and <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#dynamicvoxelencoder"><code>DynamicVoxelEncoder</code></a> classes to provide a streamlined process for transforming raw point cloud data into meaningful features that can be used in further processing, such as in neural networks for tasks like object detection, segmentation, or 3D scene understanding.</p>
<ul>
<li><p>How <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#voxelfeaturenet"><code>VoxelFeatureNet</code></a> Works:</p>
<ol type="1">
<li><strong>VoxelNet Integration:</strong></li>
</ol>
<ul>
<li><code>VoxelNet</code> is responsible for dynamically voxelizing the input point clouds.</li>
<li>It first takes raw point cloud data (<code>points</code>), which includes the batch index and the coordinates (x, y, z), along with other associated features.</li>
<li>The point cloud data is mapped onto a voxel grid based on the specified <code>voxel_size</code> and <code>pc_range</code>.</li>
<li>Points that fall outside the specified range are filtered out.</li>
<li>The voxel grid coordinates for each point are calculated and stored, and duplicate voxel indices are merged, with unique voxel indices being identified (<code>unq</code>), and a mapping from points to voxels is maintained (<code>unq_inv</code>).</li>
</ul>
<ol start="2" type="1">
<li><strong>DynamicVoxelEncoder Integration:</strong></li>
</ol>
<ul>
<li>Once the voxelization process is completed, the <code>DynamicVoxelEncoder</code> takes over.</li>
<li>This encoder aggregates the features of all points that fall into the same voxel by computing the mean of the features (<code>scatter_mean</code> function).</li>
<li>This step effectively reduces the point cloud data into a more compact voxel-based representation, where each voxel holds the average feature of all points within it.</li>
</ul>
<ol start="3" type="1">
<li><strong>Return Values:</strong></li>
</ol>
<ul>
<li>The class returns the aggregated voxel features, the voxel coordinates (<code>coords</code>), and the grid size (<code>grid_size</code>), which can be used for further processing in downstream tasks.</li>
</ul></li>
</ul>
<p>Overall, <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#voxelfeaturenet"><code>VoxelFeatureNet</code></a> provides a structured way to convert raw point cloud data into voxelized features.</p>
<div id="cell-28" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an instance of VoxelFeatureNet</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.1</span>, <span class="fl">0.1</span>]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>pc_range <span class="op">=</span> [<span class="dv">0</span>, <span class="op">-</span><span class="dv">40</span>, <span class="op">-</span><span class="dv">3</span>, <span class="fl">70.4</span>, <span class="dv">40</span>, <span class="dv">1</span>]</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>voxel_feature_net <span class="op">=</span> VoxelFeatureNet(voxel_size, pc_range)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic point cloud data</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Format: [batch_id, x, y, z, ...]</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>num_points <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>num_features <span class="op">=</span> <span class="dv">4</span>  <span class="co"># x, y, z, intensity</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> torch.cat([</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    torch.randint(<span class="dv">0</span>, batch_size, (num_points, <span class="dv">1</span>)).<span class="bu">float</span>(),  <span class="co"># batch_id</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    torch.rand(num_points, <span class="dv">3</span>) <span class="op">*</span> torch.tensor([<span class="fl">70.4</span>, <span class="dv">80</span>, <span class="dv">4</span>]) <span class="op">-</span> torch.tensor([<span class="dv">0</span>, <span class="dv">40</span>, <span class="dv">3</span>]),  <span class="co"># x, y, z</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    torch.rand(num_points, num_features <span class="op">-</span> <span class="dv">3</span>)  <span class="co"># additional features</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>], dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass through the VoxelFeatureNet</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>features, coords, grid_size <span class="op">=</span> voxel_feature_net(points)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-29" class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visual demonstration using matplotlib</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_voxel_grid(coords, grid_size):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> fig.add_subplot(<span class="dv">111</span>, projection<span class="op">=</span><span class="st">'3d'</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the voxel grid</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    ax.set_xlim(<span class="dv">0</span>, grid_size[<span class="dv">2</span>])</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    ax.set_ylim(<span class="dv">0</span>, grid_size[<span class="dv">1</span>])</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    ax.set_zlim(<span class="dv">0</span>, grid_size[<span class="dv">0</span>])</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'X'</span>)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Y'</span>)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    ax.set_zlabel(<span class="st">'Z'</span>)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the occupied voxels</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> coord <span class="kw">in</span> coords:</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        ax.scatter(coord[<span class="dv">1</span>], coord[<span class="dv">2</span>], coord[<span class="dv">3</span>], c<span class="op">=</span><span class="st">'b'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Voxel Grid'</span>)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the voxel grid with occupied coordinates</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>plot_voxel_grid(coords, grid_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_model_readers_files/figure-html/cell-21-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="mvf-enconder" class="level2">
<h2 class="anchored" data-anchor-id="mvf-enconder">MVF Enconder</h2>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L271" target="_blank" style="float:right; font-size:smaller">source</a></p>
<section id="pointnet" class="level3">
<h3 class="anchored" data-anchor-id="pointnet">PointNet</h3>
<blockquote class="blockquote">
<pre><code> PointNet (in_channels:int, out_channels:int)</code></pre>
</blockquote>
<p><em>Linear Process for point feature</em></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>in_channels</td>
<td>int</td>
<td>Number of input channels</td>
</tr>
<tr class="even">
<td>out_channels</td>
<td>int</td>
<td>Number of output channels</td>
</tr>
</tbody>
</table>
<div id="cell-32" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PointNet(nn.Module):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Linear Process for point feature</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                in_channels:<span class="bu">int</span>, <span class="co"># Number of input channels</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>                out_channels:<span class="bu">int</span> <span class="co"># Number of output channels</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.linear <span class="op">=</span> nn.Linear(in_channels, out_channels, bias<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.norm <span class="op">=</span> nn.BatchNorm1d(out_channels, eps<span class="op">=</span><span class="fl">1e-3</span>, momentum<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, points):</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        torch.backends.cudnn.enabled <span class="op">=</span> <span class="va">False</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.linear(points)</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="va">self</span>.norm(x)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> F.relu(x)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>        torch.backends.cudnn.enabled <span class="op">=</span> <span class="va">True</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pointnet"><code>PointNet</code></a> class is a simple neural network module designed for processing point features. This class abstracts a linear transformation followed by normalization and activation.</p>
<p>The core functionality of the <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pointnet"><code>PointNet</code></a> class:</p>
<ol type="1">
<li><p><strong>Linear Transformation</strong>: It transforms the input features (point features) using a linear layer, effectively mapping the input dimension (<code>in_channels</code>) to the desired output dimension (<code>out_channels</code>).</p></li>
<li><p><strong>Normalization</strong>: After the linear transformation, the features are normalized using Batch Normalization to ensure stable and faster training by maintaining consistent feature distributions.</p></li>
<li><p><strong>Activation</strong>: The normalized features are passed through a ReLU activation function, introducing non-linearity and enabling the network to model complex relationships between input features.</p></li>
</ol>
<p><strong>Fixed Architecture</strong>:</p>
<ul>
<li>The class is hardcoded to a single linear layer followed by batch normalization and ReLU activation. This limits its flexibility if more complex architectures or other types of layers (e.g., convolutional layers, more sophisticated non-linearities) are needed. Also it isn’t possible to change the number of layers or the activation function, nor the epsilon and momentum values for batch normalization, since they are hardcoded.</li>
</ul>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L294" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="pillarvoxelnet" class="level3">
<h3 class="anchored" data-anchor-id="pillarvoxelnet">PillarVoxelNet</h3>
<blockquote class="blockquote">
<pre><code> PillarVoxelNet (voxel_size, pc_range)</code></pre>
</blockquote>
<p><em>This class implements the voxelization process, converting point clouds into voxel grid indices and computing features for each point relative to the voxel grid.</em></p>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>voxel_size</td>
<td>Size of of each voxel in the grid, only utilize x and y size.</td>
</tr>
<tr class="even">
<td>pc_range</td>
<td>Point cloud range. Only utilize x and y min.</td>
</tr>
</tbody>
</table>
<div id="cell-35" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PillarVoxelNet(nn.Module):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">    This class implements the voxelization process, converting point clouds into voxel grid indices and computing features for each point relative to the voxel grid.</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>                voxel_size, <span class="co"># Size of of each voxel in the grid, only utilize x and y size.</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                pc_range <span class="co"># Point cloud range. Only utilize x and y min.</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_size <span class="op">=</span> np.array(voxel_size)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pc_range <span class="op">=</span> np.array(pc_range)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, points):</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        device <span class="op">=</span> points.device</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>        dtype <span class="op">=</span> points.dtype</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> (<span class="va">self</span>.pc_range[<span class="dv">3</span>:] <span class="op">-</span> <span class="va">self</span>.pc_range[:<span class="dv">3</span>]</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>                     )<span class="op">/</span><span class="va">self</span>.voxel_size  <span class="co"># x,  y, z</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> np.<span class="bu">round</span>(grid_size, <span class="dv">0</span>, grid_size).astype(np.int64)</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        voxel_size <span class="op">=</span> torch.from_numpy(</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.voxel_size).type_as(points).to(device)</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>        pc_range <span class="op">=</span> torch.from_numpy(<span class="va">self</span>.pc_range).type_as(points).to(device)</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> (</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>            points[:, <span class="dv">1</span>:<span class="dv">4</span>] <span class="op">-</span> pc_range[:<span class="dv">3</span>].view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)) <span class="op">/</span> voxel_size.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)   <span class="co"># x, y, z</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>        points_coords[:, <span class="dv">0</span>] <span class="op">=</span> torch.clamp(</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>            points_coords[:, <span class="dv">0</span>], <span class="dv">0</span>, grid_size[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>        points_coords[:, <span class="dv">1</span>] <span class="op">=</span> torch.clamp(</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>            points_coords[:, <span class="dv">1</span>], <span class="dv">0</span>, grid_size[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>        points_coords[:, <span class="dv">2</span>] <span class="op">=</span> torch.clamp(</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>            points_coords[:, <span class="dv">2</span>], <span class="dv">0</span>, grid_size[<span class="dv">2</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> points_coords.<span class="bu">long</span>()</span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>        batch_idx <span class="op">=</span> points[:, <span class="dv">0</span>:<span class="dv">1</span>].<span class="bu">long</span>()</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>        points_index <span class="op">=</span> torch.cat((batch_idx, points_coords[:, :<span class="dv">2</span>]), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>        unq, unq_inv <span class="op">=</span> torch.unique(points_index, return_inverse<span class="op">=</span><span class="va">True</span>, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>        unq <span class="op">=</span> unq.<span class="bu">int</span>()        <span class="co"># breakpoint()</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>        points_mean_scatter <span class="op">=</span> torch_scatter.scatter_mean(</span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>            points[:, <span class="dv">1</span>:<span class="dv">4</span>], unq_inv, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>        f_cluster <span class="op">=</span> points[:, <span class="dv">1</span>:<span class="dv">4</span>] <span class="op">-</span> points_mean_scatter[unq_inv]</span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find distance of x, y, and z from pillar center</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>        f_center <span class="op">=</span> points[:, <span class="dv">1</span>:<span class="dv">3</span>] <span class="op">-</span> (points_coords[:, :<span class="dv">2</span>].to(dtype) <span class="op">*</span> voxel_size[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>                                     voxel_size[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>) <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> pc_range[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>))</span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine together feature decorations</span></span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> torch.cat([points[:, <span class="dv">1</span>:], f_cluster, f_center], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> features, unq[:, [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>]], unq_inv, grid_size[[<span class="dv">1</span>, <span class="dv">0</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarvoxelnet"><code>PillarVoxelNet</code></a> class is a component in the process of converting raw LiDAR point cloud data into a structured grid format for 3D object detection tasks. It is designed to convert unstructured LiDAR point cloud data into a structured voxel grid. By transforming the raw point data into a format that can be processed by the subsequent network layers, the class enables the network to capture spatial relationships.</p>
<p>Components of the Class:</p>
<p><strong>Forward Pass (<code>forward</code> Method):</strong></p>
<p>The <code>forward</code> method takes in a batch of point cloud data and performs the following steps:</p>
<ul>
<li><p><strong>Grid Size Calculation:</strong> The grid size (number of voxels along each axis) is calculated by dividing the range of the point cloud by the voxel size. This defines how many voxels fit into the defined point cloud range.</p></li>
<li><p><strong>Voxelization:</strong> Each point in the point cloud is converted to a coordinate within the voxel grid. This is done by normalizing the point coordinates by the voxel size and adjusting them relative to the grid.</p>
<p>The coordinates are then clamped to ensure they lie within the bounds of the grid.</p></li>
<li><p><strong>Unique Voxel Identification:</strong> The points are then assigned to unique voxels based on their calculated voxel coordinates. The <code>torch.unique</code> function is used to identify unique voxel indices and the corresponding inverse indices.</p></li>
<li><p><strong>Feature Computation:</strong></p>
<ul>
<li><strong>Point-to-Pillar Mean:</strong> The mean position of points within each voxel (or pillar) is calculated.</li>
<li><strong>Cluster Features (<code>f_cluster</code>):</strong> These features represent the offset of each point from the mean position of its corresponding voxel.</li>
<li><strong>Centering Features (<code>f_center</code>):</strong> These features represent the distance of each point from the center of the voxel grid.</li>
</ul>
<p>Finally, the original point features, cluster features, and centering features are concatenated to form the final set of features for each point.</p></li>
<li><p><strong>Return Values:</strong> The method returns:</p>
<ul>
<li><code>features</code>: The enhanced point features incorporating spatial relationships.</li>
<li><code>unq</code>: The unique voxel indices.</li>
<li><code>unq_inv</code>: Inverse indices for reconstructing the original point set.</li>
<li><code>grid_size</code>: The size of the voxel grid in the x and y dimensions.</li>
</ul></li>
</ul>
<div id="cell-37" class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an instance of PillarVoxelNet</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> [<span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="dv">4</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>pc_range <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">3</span>, <span class="fl">70.4</span>, <span class="dv">40</span>, <span class="dv">1</span>]</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>pillar_voxel_net <span class="op">=</span> PillarVoxelNet(voxel_size, pc_range)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic point cloud data</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>num_points <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> torch.rand(num_points, <span class="dv">4</span>)</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># All points belong to the same batch</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">1</span>] <span class="op">=</span> points[:, <span class="dv">1</span>] <span class="op">*</span> (pc_range[<span class="dv">3</span>] <span class="op">-</span> pc_range[<span class="dv">0</span>]) <span class="op">+</span> pc_range[<span class="dv">0</span>]</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">2</span>] <span class="op">=</span> points[:, <span class="dv">2</span>] <span class="op">*</span> (pc_range[<span class="dv">4</span>] <span class="op">-</span> pc_range[<span class="dv">1</span>]) <span class="op">+</span> pc_range[<span class="dv">1</span>]</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">3</span>] <span class="op">=</span> points[:, <span class="dv">3</span>] <span class="op">*</span> (pc_range[<span class="dv">5</span>] <span class="op">-</span> pc_range[<span class="dv">2</span>]) <span class="op">+</span> pc_range[<span class="dv">2</span>]</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>features, unq, unq_inv, grid_size <span class="op">=</span> pillar_voxel_net(points)</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the results</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Features:"</span>)</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(features)</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Unique Pillar Indices (Batch, X, Y):"</span>)</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(unq)</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Grid Size (Y, X):"</span>)</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(grid_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Features:
tensor([[ 2.3704e+01,  2.8256e+01, -1.9798e+00,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  3.5553e-03, -4.4041e-02],
        [ 1.0087e+01,  6.1095e+00, -3.1646e-01,  0.0000e+00,  0.0000e+00,
          0.0000e+00, -1.3090e-02,  9.5429e-03],
        [ 5.4948e+01,  1.8746e+01, -2.3587e+00,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  4.7882e-02,  4.5704e-02],
        [ 5.5123e+01,  1.7003e+01, -2.0925e+00,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  2.3098e-02, -9.7160e-02],
        [ 5.7509e+01,  1.8222e+01, -2.2636e+00,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  9.4337e-03, -7.7551e-02],
        [ 4.1481e+01,  2.1276e+01, -6.7486e-01,  0.0000e+00,  0.0000e+00,
          0.0000e+00, -1.9176e-02, -2.3525e-02],
        [ 9.8798e-01,  3.4320e+01,  1.4192e-01,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  8.7983e-02,  1.9520e-02],
        [ 5.6135e+01,  2.2593e+01, -1.4039e+00,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  3.4702e-02,  9.2648e-02],
        [ 6.3527e+01,  2.6058e+00, -2.0011e+00,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  2.6817e-02, -9.4187e-02],
        [ 5.2936e+01,  1.1646e+01,  8.8765e-01,  0.0000e+00,  0.0000e+00,
          0.0000e+00,  3.5934e-02, -5.4329e-02]])

Unique Pillar Indices (Batch, X, Y):
tensor([[  0, 171,   4],
        [  0,  30,  50],
        [  0, 141, 118],
        [  0, 106, 207],
        [  0,  58, 264],
        [  0,  93, 274],
        [  0,  85, 275],
        [  0, 112, 280],
        [  0,  91, 287],
        [  0,  13, 317]], dtype=torch.int32)

Grid Size (Y, X):
[200 352]</code></pre>
</div>
</div>
<div id="cell-38" class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create an instance of PillarVoxelNet</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> [<span class="fl">0.2</span>, <span class="fl">0.2</span>, <span class="dv">4</span>]</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>pc_range <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">3</span>, <span class="fl">70.4</span>, <span class="dv">40</span>, <span class="dv">1</span>]</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>pillar_voxel_net <span class="op">=</span> PillarVoxelNet(voxel_size, pc_range)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate synthetic point cloud data</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>num_points <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> torch.rand(num_points, <span class="dv">4</span>)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># All points belong to the same batch</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">1</span>] <span class="op">=</span> points[:, <span class="dv">1</span>] <span class="op">*</span> (pc_range[<span class="dv">3</span>] <span class="op">-</span> pc_range[<span class="dv">0</span>]) <span class="op">+</span> pc_range[<span class="dv">0</span>]</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">2</span>] <span class="op">=</span> points[:, <span class="dv">2</span>] <span class="op">*</span> (pc_range[<span class="dv">4</span>] <span class="op">-</span> pc_range[<span class="dv">1</span>]) <span class="op">+</span> pc_range[<span class="dv">1</span>]</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>points[:, <span class="dv">3</span>] <span class="op">=</span> points[:, <span class="dv">3</span>] <span class="op">*</span> (pc_range[<span class="dv">5</span>] <span class="op">-</span> pc_range[<span class="dv">2</span>]) <span class="op">+</span> pc_range[<span class="dv">2</span>]</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>features, unq, unq_inv, grid_size <span class="op">=</span> pillar_voxel_net(points)</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="co"># # Plot original point cloud</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>plt.scatter(points[:, <span class="dv">1</span>], points[:, <span class="dv">2</span>], c<span class="op">=</span>points[:, <span class="dv">3</span>], cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">'Z Coordinate'</span>)</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Original Point Cloud'</span>)</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'X'</span>)</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Y'</span>)</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot voxelized point cloud (colored by unique pillar indices)</span></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>unique_pillar_colors <span class="op">=</span> plt.cm.get_cmap(<span class="st">'tab20'</span>, <span class="bu">len</span>(unq))</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>color_map <span class="op">=</span> unique_pillar_colors(unq_inv.numpy() <span class="op">%</span> <span class="bu">len</span>(unq))</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>plt.scatter(points[:, <span class="dv">1</span>], points[:, <span class="dv">2</span>], c<span class="op">=</span>color_map, s<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Voxelized Point Cloud (Colored by Unique Pillar Indices)'</span>)</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'X'</span>)</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Y'</span>)</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_model_readers_files/figure-html/cell-27-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="05_model_readers_files/figure-html/cell-27-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L349" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
<section id="cylindernet" class="level3">
<h3 class="anchored" data-anchor-id="cylindernet">CylinderNet</h3>
<blockquote class="blockquote">
<pre><code> CylinderNet (voxel_size, pc_range)</code></pre>
</blockquote>
<p>*Base class for all neural network modules.</p>
<p>Your models should also subclass this class.</p>
<p>Modules can also contain other Modules, allowing to nest them in a tree structure. You can assign the submodules as regular attributes::</p>
<pre><code>import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))</code></pre>
<p>Submodules assigned in this way will be registered, and will have their parameters converted too when you call :meth:<code>to</code>, etc.</p>
<p>.. note:: As per the example above, an <code>__init__()</code> call to the parent class must be made before assignment on the child.</p>
<table class="caption-top table">
<caption>ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*</caption>
<thead>
<tr class="header">
<th></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>voxel_size</td>
<td>Size of each voxel, only utilize x and y size</td>
</tr>
<tr class="even">
<td>pc_range</td>
<td>Point cloud range, only utilize x and y min</td>
</tr>
</tbody>
</table>
<div id="cell-40" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CylinderNet(nn.Module):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                voxel_size, <span class="co"># Size of each voxel, only utilize x and y size</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>                pc_range <span class="co"># Point cloud range, only utilize x and y min</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_size <span class="op">=</span> np.array(voxel_size)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pc_range <span class="op">=</span> np.array(pc_range)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, points):</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        device <span class="op">=</span> points.device</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>        dtype <span class="op">=</span> points.dtype</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        points_x <span class="op">=</span> points[:, <span class="dv">1</span>:<span class="dv">2</span>]</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        points_y <span class="op">=</span> points[:, <span class="dv">2</span>:<span class="dv">3</span>]</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>        points_z <span class="op">=</span> points[:, <span class="dv">3</span>:<span class="dv">4</span>]</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>        points_phi <span class="op">=</span> torch.atan2(points_y, points_x) <span class="op">/</span> np.pi <span class="op">*</span> <span class="dv">180</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>        points_rho <span class="op">=</span> torch.sqrt(points_x <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> points_y <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>        points_cylinder <span class="op">=</span> torch.cat(</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>            (points[:, <span class="dv">0</span>:<span class="dv">1</span>], points_phi, points_z, points_rho, points[:, <span class="dv">4</span>:]), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> (<span class="va">self</span>.pc_range[<span class="dv">3</span>:] <span class="op">-</span> <span class="va">self</span>.pc_range[:<span class="dv">3</span>]</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>                     )<span class="op">/</span><span class="va">self</span>.voxel_size  <span class="co"># phi, z, rho</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>        grid_size <span class="op">=</span> np.<span class="bu">round</span>(grid_size, <span class="dv">0</span>, grid_size).astype(np.int64)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>        voxel_size <span class="op">=</span> torch.from_numpy(</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.voxel_size).type_as(points).to(device)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>        pc_range <span class="op">=</span> torch.from_numpy(<span class="va">self</span>.pc_range).type_as(points).to(device)</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> (</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>            points_cylinder[:, <span class="dv">1</span>:<span class="dv">4</span>] <span class="op">-</span> pc_range[:<span class="dv">3</span>].view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)) <span class="op">/</span> voxel_size.view(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>        points_coords[:, <span class="dv">0</span>] <span class="op">=</span> torch.clamp(</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>            points_coords[:, <span class="dv">0</span>], <span class="dv">0</span>, grid_size[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>        points_coords[:, <span class="dv">1</span>] <span class="op">=</span> torch.clamp(</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>            points_coords[:, <span class="dv">1</span>], <span class="dv">0</span>, grid_size[<span class="dv">1</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>        points_coords[:, <span class="dv">2</span>] <span class="op">=</span> torch.clamp(</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>            points_coords[:, <span class="dv">2</span>], <span class="dv">0</span>, grid_size[<span class="dv">2</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>        points_coords <span class="op">=</span> points_coords.<span class="bu">long</span>()</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>        batch_idx <span class="op">=</span> points_cylinder[:, <span class="dv">0</span>:<span class="dv">1</span>].<span class="bu">long</span>()</span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>        points_index <span class="op">=</span> torch.cat((batch_idx, points_coords[:, :<span class="dv">2</span>]), dim<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>        unq, unq_inv <span class="op">=</span> torch.unique(points_index, return_inverse<span class="op">=</span><span class="va">True</span>, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>        unq <span class="op">=</span> unq.<span class="bu">int</span>()</span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>        points_mean_scatter <span class="op">=</span> torch_scatter.scatter_mean(</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a>            points_cylinder[:, <span class="dv">1</span>:<span class="dv">4</span>], unq_inv, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a>        f_cluster <span class="op">=</span> points_cylinder[:, <span class="dv">1</span>:<span class="dv">4</span>] <span class="op">-</span> points_mean_scatter[unq_inv]</span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find distance of x, y, and z from pillar center</span></span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a>        f_center <span class="op">=</span> points_cylinder[:, <span class="dv">1</span>:<span class="dv">3</span>] <span class="op">-</span> (points_coords[:, :<span class="dv">2</span>].to(dtype) <span class="op">*</span> voxel_size[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a>                                              voxel_size[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>) <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> pc_range[:<span class="dv">2</span>].unsqueeze(<span class="dv">0</span>))</span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine together feature decorations</span></span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> torch.cat(</span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true" tabindex="-1"></a>            [points_cylinder[:, <span class="dv">1</span>:], f_cluster, f_center], dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> features, unq[:, [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>]], unq_inv, grid_size[[<span class="dv">1</span>, <span class="dv">0</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#cylindernet"><code>CylinderNet</code></a> class is a neural network module designed to transform the raw point cloud data into a cylindrical coordinate system, then organizes the points into a structured grid based on voxelization.</p>
<section id="functionality" class="level4">
<h4 class="anchored" data-anchor-id="functionality">Functionality:</h4>
<ul>
<li><p><strong>Conversion to Cylindrical Coordinates</strong>: The point cloud data initially represented in Cartesian coordinates (x, y, z) is transformed into cylindrical coordinates (φ, z, ρ), where <code>φ</code> is the azimuthal angle, <code>z</code> is the height, and <code>ρ</code> is the radial distance from the origin. This conversion helps align the data with the sensor’s scanning pattern, making it easier to capture relevant features.</p></li>
<li><p><strong>Voxelization and Grid Size Calculation</strong>: After converting to cylindrical coordinates, the point cloud is voxelized based on the specified <code>voxel_size</code>. The <code>grid_size</code> is computed by dividing the range of the point cloud by the voxel size, resulting in the number of voxels along each axis.</p></li>
<li><p><strong>Point Indexing and Unique Coordinates</strong>: The transformed points are then mapped to voxel coordinates. Each point is assigned to a voxel based on its cylindrical coordinates. The code identifies unique voxel indices and computes scatter-based statistics, such as the mean, for each voxel, which are crucial for creating features.</p></li>
<li><p><strong>Feature Decoration</strong>: Additional features are computed for each point, including the difference from the voxel center and the cluster center. These features help the network learn more about the local geometry of the point cloud.</p></li>
</ul>
</section>
<section id="output" class="level4">
<h4 class="anchored" data-anchor-id="output">Output:</h4>
<ul>
<li><strong>features</strong>: A tensor containing the decorated features for each point, combining the cylindrical coordinates with additional features like cluster and center distances.</li>
<li><strong>unq</strong>: The unique voxel indices.</li>
<li><strong>unq_inv</strong>: The inverse mapping from unique indices to the original points, used to reconstruct the point-to-voxel relationship.</li>
<li><strong>grid_size</strong>: The size of the voxel grid, reordered to match the required format.</li>
</ul>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L407" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
</section>
<section id="singleview" class="level3">
<h3 class="anchored" data-anchor-id="singleview">SingleView</h3>
<blockquote class="blockquote">
<pre><code> SingleView (in_channels, num_filters, layer_nums, ds_layer_strides,
             ds_num_filters, kernel_size, mode, voxel_size, pc_range,
             norm_cfg=None, act_cfg=None)</code></pre>
</blockquote>
<p><em>authoured by Beijing-jinyu convolution for single view</em></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th><strong>Type</strong></th>
<th><strong>Default</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>in_channels</td>
<td></td>
<td></td>
<td>Number of input channels</td>
</tr>
<tr class="even">
<td>num_filters</td>
<td></td>
<td></td>
<td>Number of features in each of the N PFNLayers</td>
</tr>
<tr class="odd">
<td>layer_nums</td>
<td></td>
<td></td>
<td>Number of blocks in each layer</td>
</tr>
<tr class="even">
<td>ds_layer_strides</td>
<td></td>
<td></td>
<td>Strides of each layer</td>
</tr>
<tr class="odd">
<td>ds_num_filters</td>
<td></td>
<td></td>
<td>Number of features in each layer</td>
</tr>
<tr class="even">
<td>kernel_size</td>
<td></td>
<td></td>
<td>Kernel size of each layer</td>
</tr>
<tr class="odd">
<td>mode</td>
<td></td>
<td></td>
<td>Mode of the network</td>
</tr>
<tr class="even">
<td>voxel_size</td>
<td></td>
<td></td>
<td>Size of voxels, only utilize x and y size</td>
</tr>
<tr class="odd">
<td>pc_range</td>
<td></td>
<td></td>
<td>Point cloud range, only utilize x and y min</td>
</tr>
<tr class="even">
<td>norm_cfg</td>
<td>NoneType</td>
<td>None</td>
<td>Normalization config</td>
</tr>
<tr class="odd">
<td>act_cfg</td>
<td>NoneType</td>
<td>None</td>
<td>Activation config</td>
</tr>
</tbody>
</table>
<div id="cell-43" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SingleView(nn.Module):</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">    authoured by Beijing-jinyu</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">    convolution for single view</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>                 in_channels,  <span class="co"># Number of input channels</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>                 num_filters,  <span class="co"># Number of features in each of the N PFNLayers</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>                 layer_nums,  <span class="co"># Number of blocks in each layer</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>                 ds_layer_strides,  <span class="co"># Strides of each layer</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>                 ds_num_filters,  <span class="co"># Number of features in each layer</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>                 kernel_size,  <span class="co"># Kernel size of each layer</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>                 mode,  <span class="co"># Mode of the network</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>                 voxel_size,  <span class="co"># Size of voxels, only utilize x and y size</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>                 pc_range,  <span class="co"># Point cloud range, only utilize x and y min</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>                 norm_cfg<span class="op">=</span><span class="va">None</span>,  <span class="co"># Normalization config</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>                 act_cfg<span class="op">=</span><span class="va">None</span>,  <span class="co"># Activation config</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>                 ):</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.mode <span class="op">=</span> mode</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_size <span class="op">=</span> np.array(voxel_size[:<span class="dv">2</span>])</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bias <span class="op">=</span> np.array(pc_range[:<span class="dv">2</span>])</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        num_filters <span class="op">=</span> [in_channels] <span class="op">+</span> <span class="bu">list</span>(num_filters)</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>        pfn_layers <span class="op">=</span> []</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(num_filters) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>            in_filters <span class="op">=</span> num_filters[i]</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>            out_filters <span class="op">=</span> num_filters[i <span class="op">+</span> <span class="dv">1</span>]</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(num_filters) <span class="op">-</span> <span class="dv">2</span>:</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>                last_layer <span class="op">=</span> <span class="va">False</span></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>                last_layer <span class="op">=</span> <span class="va">True</span></span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>            pfn_layers.append(</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>                PFNLayer(</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>                    in_filters, out_filters, norm_cfg<span class="op">=</span>norm_cfg, last_layer<span class="op">=</span>last_layer</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>        in_filters <span class="op">=</span> [num_filters[<span class="op">-</span><span class="dv">1</span>], <span class="op">*</span>ds_num_filters[:<span class="op">-</span><span class="dv">1</span>]]</span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pfn_layers <span class="op">=</span> nn.ModuleList(pfn_layers)</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>        blocks <span class="op">=</span> []</span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, layer_num <span class="kw">in</span> <span class="bu">enumerate</span>(layer_nums):</span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>            block <span class="op">=</span> <span class="va">self</span>._make_layer(</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>                in_filters[i],</span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>                ds_num_filters[i],</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>                kernel_size[i],</span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>                ds_layer_strides[i],</span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a>                layer_num)</span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a>            blocks.append(block)</span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.blocks <span class="op">=</span> nn.ModuleList(blocks)</span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ds_rate <span class="op">=</span> np.prod(np.array(ds_layer_strides))</span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _make_layer(<span class="va">self</span>, inplanes, planes, kernel_size, stride, num_blocks):</span>
<span id="cb36-54"><a href="#cb36-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-55"><a href="#cb36-55" aria-hidden="true" tabindex="-1"></a>        layers <span class="op">=</span> []</span>
<span id="cb36-56"><a href="#cb36-56" aria-hidden="true" tabindex="-1"></a>        layers.append(SparseConvBlock(inplanes, planes,</span>
<span id="cb36-57"><a href="#cb36-57" aria-hidden="true" tabindex="-1"></a>                      kernel_size<span class="op">=</span>kernel_size, stride<span class="op">=</span>stride, use_subm<span class="op">=</span><span class="va">False</span>))</span>
<span id="cb36-58"><a href="#cb36-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-59"><a href="#cb36-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(num_blocks):</span>
<span id="cb36-60"><a href="#cb36-60" aria-hidden="true" tabindex="-1"></a>            layers.append(SparseBasicBlock(planes, kernel_size<span class="op">=</span>kernel_size))</span>
<span id="cb36-61"><a href="#cb36-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-62"><a href="#cb36-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> spconv.pytorch.SparseSequential(<span class="op">*</span>layers)</span>
<span id="cb36-63"><a href="#cb36-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-64"><a href="#cb36-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, features, unq, unq_inv, grid_size):</span>
<span id="cb36-65"><a href="#cb36-65" aria-hidden="true" tabindex="-1"></a>        feature_pos <span class="op">=</span> features[:,</span>
<span id="cb36-66"><a href="#cb36-66" aria-hidden="true" tabindex="-1"></a>                               <span class="dv">0</span>:<span class="dv">2</span>] <span class="cf">if</span> <span class="va">self</span>.mode <span class="op">==</span> <span class="st">'pillar'</span> <span class="cf">else</span> features[:, <span class="dv">10</span>:<span class="dv">12</span>]</span>
<span id="cb36-67"><a href="#cb36-67" aria-hidden="true" tabindex="-1"></a>        device <span class="op">=</span> feature_pos.device</span>
<span id="cb36-68"><a href="#cb36-68" aria-hidden="true" tabindex="-1"></a>        voxel_size <span class="op">=</span> torch.from_numpy(</span>
<span id="cb36-69"><a href="#cb36-69" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.voxel_size).type_as(feature_pos).to(device)</span>
<span id="cb36-70"><a href="#cb36-70" aria-hidden="true" tabindex="-1"></a>        bias <span class="op">=</span> torch.from_numpy(<span class="va">self</span>.bias).type_as(feature_pos).to(device)</span>
<span id="cb36-71"><a href="#cb36-71" aria-hidden="true" tabindex="-1"></a>        feature_pos <span class="op">=</span> (feature_pos <span class="op">-</span> bias) <span class="op">/</span> voxel_size</span>
<span id="cb36-72"><a href="#cb36-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-73"><a href="#cb36-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pfn <span class="kw">in</span> <span class="va">self</span>.pfn_layers:</span>
<span id="cb36-74"><a href="#cb36-74" aria-hidden="true" tabindex="-1"></a>            features <span class="op">=</span> pfn(features, unq_inv)  <span class="co"># num_points, dim_feat</span></span>
<span id="cb36-75"><a href="#cb36-75" aria-hidden="true" tabindex="-1"></a>        features_voxel <span class="op">=</span> torch_scatter.scatter_max(features, unq_inv, dim<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb36-76"><a href="#cb36-76" aria-hidden="true" tabindex="-1"></a>        batch_size <span class="op">=</span> <span class="bu">len</span>(torch.unique(unq[:, <span class="dv">0</span>]))</span>
<span id="cb36-77"><a href="#cb36-77" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> spconv.pytorch.SparseConvTensor(</span>
<span id="cb36-78"><a href="#cb36-78" aria-hidden="true" tabindex="-1"></a>            features_voxel, unq, grid_size, batch_size)</span>
<span id="cb36-79"><a href="#cb36-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-80"><a href="#cb36-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(<span class="va">self</span>.blocks)):</span>
<span id="cb36-81"><a href="#cb36-81" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> <span class="va">self</span>.blocks[i](x)</span>
<span id="cb36-82"><a href="#cb36-82" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x.dense()</span>
<span id="cb36-83"><a href="#cb36-83" aria-hidden="true" tabindex="-1"></a>        feature_pos <span class="op">=</span> torch.cat(</span>
<span id="cb36-84"><a href="#cb36-84" aria-hidden="true" tabindex="-1"></a>            (unq[unq_inv][:, <span class="dv">0</span>:<span class="dv">1</span>], feature_pos <span class="op">/</span> <span class="va">self</span>.ds_rate), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb36-85"><a href="#cb36-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-86"><a href="#cb36-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.bilinear_interpolate(x, feature_pos)</span>
<span id="cb36-87"><a href="#cb36-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-88"><a href="#cb36-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> bilinear_interpolate(<span class="va">self</span>, image, coords):</span>
<span id="cb36-89"><a href="#cb36-89" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb36-90"><a href="#cb36-90" aria-hidden="true" tabindex="-1"></a><span class="co">        image: (B, C, H, W)</span></span>
<span id="cb36-91"><a href="#cb36-91" aria-hidden="true" tabindex="-1"></a><span class="co">        coords: (N, 3): (B, y, x)</span></span>
<span id="cb36-92"><a href="#cb36-92" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb36-93"><a href="#cb36-93" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> coords[:, <span class="dv">1</span>]</span>
<span id="cb36-94"><a href="#cb36-94" aria-hidden="true" tabindex="-1"></a>        x0 <span class="op">=</span> torch.floor(x).<span class="bu">long</span>()</span>
<span id="cb36-95"><a href="#cb36-95" aria-hidden="true" tabindex="-1"></a>        x1 <span class="op">=</span> x0 <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb36-96"><a href="#cb36-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-97"><a href="#cb36-97" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> coords[:, <span class="dv">2</span>]</span>
<span id="cb36-98"><a href="#cb36-98" aria-hidden="true" tabindex="-1"></a>        y0 <span class="op">=</span> torch.floor(y).<span class="bu">long</span>()</span>
<span id="cb36-99"><a href="#cb36-99" aria-hidden="true" tabindex="-1"></a>        y1 <span class="op">=</span> y0 <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb36-100"><a href="#cb36-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-101"><a href="#cb36-101" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> coords[:, <span class="dv">0</span>].<span class="bu">long</span>()</span>
<span id="cb36-102"><a href="#cb36-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-103"><a href="#cb36-103" aria-hidden="true" tabindex="-1"></a>        x0 <span class="op">=</span> torch.clamp(x0, <span class="dv">0</span>, image.shape[<span class="dv">3</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb36-104"><a href="#cb36-104" aria-hidden="true" tabindex="-1"></a>        x1 <span class="op">=</span> torch.clamp(x1, <span class="dv">0</span>, image.shape[<span class="dv">3</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb36-105"><a href="#cb36-105" aria-hidden="true" tabindex="-1"></a>        y0 <span class="op">=</span> torch.clamp(y0, <span class="dv">0</span>, image.shape[<span class="dv">2</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb36-106"><a href="#cb36-106" aria-hidden="true" tabindex="-1"></a>        y1 <span class="op">=</span> torch.clamp(y1, <span class="dv">0</span>, image.shape[<span class="dv">2</span>] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb36-107"><a href="#cb36-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-108"><a href="#cb36-108" aria-hidden="true" tabindex="-1"></a>        Ia <span class="op">=</span> image[B, :, y0, x0]</span>
<span id="cb36-109"><a href="#cb36-109" aria-hidden="true" tabindex="-1"></a>        Ib <span class="op">=</span> image[B, :, y1, x0]</span>
<span id="cb36-110"><a href="#cb36-110" aria-hidden="true" tabindex="-1"></a>        Ic <span class="op">=</span> image[B, :, y0, x1]</span>
<span id="cb36-111"><a href="#cb36-111" aria-hidden="true" tabindex="-1"></a>        Id <span class="op">=</span> image[B, :, y1, x1]</span>
<span id="cb36-112"><a href="#cb36-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-113"><a href="#cb36-113" aria-hidden="true" tabindex="-1"></a>        wa <span class="op">=</span> ((x1.<span class="bu">type</span>(torch.float32)<span class="op">-</span>x) <span class="op">*</span></span>
<span id="cb36-114"><a href="#cb36-114" aria-hidden="true" tabindex="-1"></a>              (y1.<span class="bu">type</span>(torch.float32)<span class="op">-</span>y)).unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb36-115"><a href="#cb36-115" aria-hidden="true" tabindex="-1"></a>        wb <span class="op">=</span> ((x1.<span class="bu">type</span>(torch.float32)<span class="op">-</span>x) <span class="op">*</span></span>
<span id="cb36-116"><a href="#cb36-116" aria-hidden="true" tabindex="-1"></a>              (y<span class="op">-</span>y0.<span class="bu">type</span>(torch.float32))).unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb36-117"><a href="#cb36-117" aria-hidden="true" tabindex="-1"></a>        wc <span class="op">=</span> ((x<span class="op">-</span>x0.<span class="bu">type</span>(torch.float32)) <span class="op">*</span></span>
<span id="cb36-118"><a href="#cb36-118" aria-hidden="true" tabindex="-1"></a>              (y1.<span class="bu">type</span>(torch.float32)<span class="op">-</span>y)).unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb36-119"><a href="#cb36-119" aria-hidden="true" tabindex="-1"></a>        wd <span class="op">=</span> ((x<span class="op">-</span>x0.<span class="bu">type</span>(torch.float32)) <span class="op">*</span></span>
<span id="cb36-120"><a href="#cb36-120" aria-hidden="true" tabindex="-1"></a>              (y<span class="op">-</span>y0.<span class="bu">type</span>(torch.float32))).unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb36-121"><a href="#cb36-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-122"><a href="#cb36-122" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> Ia <span class="op">*</span> wa <span class="op">+</span> Ib <span class="op">*</span> wb <span class="op">+</span> Ic <span class="op">*</span> wc <span class="op">+</span> Id <span class="op">*</span> wd</span>
<span id="cb36-123"><a href="#cb36-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-124"><a href="#cb36-124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> features</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#singleview"><code>SingleView</code></a> class is designed to perform convolutions on single views of LiDAR data. This class processes the input data through a series of convolutional layers.</p>
<section id="main-methods" class="level4">
<h4 class="anchored" data-anchor-id="main-methods"><strong>Main Methods</strong></h4>
<ol type="1">
<li><p><strong><code>_make_layer()</code>:</strong> This method constructs a sequence of convolutional blocks (using sparse convolutions) for a particular layer, depending on the number of blocks specified.</p></li>
<li><p><strong><code>forward()</code>:</strong> This method defines the forward pass of the network. It processes the input features through the PFNLayers and blocks, applies voxelization, and finally performs bilinear interpolation to match the original resolution.</p></li>
<li><p><strong><code>bilinear_interpolate()</code>:</strong> This method performs bilinear interpolation to upscale the sparse feature maps to a dense format, using the original spatial coordinates of the features.</p></li>
</ol>
<div id="cell-45" class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Instantiate the SingleView model</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>in_channels <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>num_filters <span class="op">=</span> [<span class="dv">128</span>, <span class="dv">256</span>]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>layer_nums <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">2</span>]</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>ds_layer_strides <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">2</span>]</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>ds_num_filters <span class="op">=</span> [<span class="dv">256</span>, <span class="dv">512</span>]</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>kernel_size <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">3</span>]</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>mode <span class="op">=</span> <span class="st">'pillar'</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>voxel_size <span class="op">=</span> [<span class="fl">0.2</span>, <span class="fl">0.2</span>]</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>pc_range <span class="op">=</span> [<span class="op">-</span><span class="dv">50</span>, <span class="op">-</span><span class="dv">50</span>]</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>norm_cfg <span class="op">=</span> <span class="va">None</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>act_cfg <span class="op">=</span> <span class="va">None</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> SingleView(in_channels, num_filters, layer_nums, ds_layer_strides, ds_num_filters, kernel_size, mode, voxel_size, pc_range, norm_cfg, act_cfg).to(DEVICE)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create dummy data and transfer to the same device</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> torch.randn(<span class="dv">1000</span>, <span class="dv">64</span>, dtype<span class="op">=</span>torch.float32).to(DEVICE)</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>unq <span class="op">=</span> torch.randint(<span class="dv">0</span>, <span class="dv">10</span>, (<span class="dv">1000</span>, <span class="dv">3</span>), dtype<span class="op">=</span>torch.int32).to(DEVICE)</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>unq_inv <span class="op">=</span> torch.randint(<span class="dv">0</span>, <span class="dv">1000</span>, (<span class="dv">1000</span>,), dtype<span class="op">=</span>torch.int64).to(DEVICE)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>grid_size <span class="op">=</span> [<span class="dv">200</span>, <span class="dv">200</span>]  <span class="co"># 2D spatial shape</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Input shapes</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Features Shape:"</span>, features.shape)</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Forward pass</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>output_features <span class="op">=</span> model(features, unq, unq_inv, grid_size)</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Output Features Shape:"</span>, output_features.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Features Shape: torch.Size([1000, 64])
Output Features Shape: torch.Size([1000, 512])</code></pre>
</div>
</div>
<hr>
<p><a href="https://github.com/AIR-UFG/pillarnext_explained/blob/main/pillarnext_explained/models/model_readers.py#L533" target="_blank" style="float:right; font-size:smaller">source</a></p>
</section>
</section>
<section id="mvffeaturenet" class="level3">
<h3 class="anchored" data-anchor-id="mvffeaturenet">MVFFeatureNet</h3>
<blockquote class="blockquote">
<pre><code> MVFFeatureNet (in_channels, voxel_size, pc_range, cylinder_size,
                cylinder_range, num_filters, layer_nums, ds_layer_strides,
                ds_num_filters, kernel_size, out_channels)</code></pre>
</blockquote>
<p><em>authoured by Beijing-jinyu</em></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>in_channels</td>
<td>Number of input channels</td>
</tr>
<tr class="even">
<td>voxel_size</td>
<td>Size of voxels, only utilize x and y size</td>
</tr>
<tr class="odd">
<td>pc_range</td>
<td>Point cloud range, only utilize x and y min</td>
</tr>
<tr class="even">
<td>cylinder_size</td>
<td>Size of cylinders, only utilize x and y size</td>
</tr>
<tr class="odd">
<td>cylinder_range</td>
<td>Cylinder range, only utilize x and y min</td>
</tr>
<tr class="even">
<td>num_filters</td>
<td>Number of features in each of the N PFNLayers</td>
</tr>
<tr class="odd">
<td>layer_nums</td>
<td>Number of blocks in each layer</td>
</tr>
<tr class="even">
<td>ds_layer_strides</td>
<td>Strides of each layer</td>
</tr>
<tr class="odd">
<td>ds_num_filters</td>
<td>Number of features in each layer</td>
</tr>
<tr class="even">
<td>kernel_size</td>
<td>Kernel size of each layer</td>
</tr>
<tr class="odd">
<td>out_channels</td>
<td>Number of output channels</td>
</tr>
</tbody>
</table>
<div id="cell-47" class="cell">
<details open="" class="code-fold">
<summary>Exported source</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MVFFeatureNet(nn.Module):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co">    authoured by Beijing-jinyu</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>                in_channels, <span class="co"># Number of input channels</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>                voxel_size, <span class="co"># Size of voxels, only utilize x and y size</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>                pc_range, <span class="co"># Point cloud range, only utilize x and y min</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>                cylinder_size, <span class="co"># Size of cylinders, only utilize x and y size</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>                cylinder_range, <span class="co"># Cylinder range, only utilize x and y min</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>                num_filters, <span class="co"># Number of features in each of the N PFNLayers</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>                layer_nums, <span class="co"># Number of blocks in each layer</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>                ds_layer_strides, <span class="co"># Strides of each layer</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>                ds_num_filters, <span class="co"># Number of features in each layer</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>                kernel_size, <span class="co"># Kernel size of each layer</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>                out_channels <span class="co"># Number of output channels</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.in_channels <span class="op">=</span> in_channels</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxel_size <span class="op">=</span> voxel_size</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pc_range <span class="op">=</span> pc_range</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cylinder_range <span class="op">=</span> cylinder_range</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cylinder_size <span class="op">=</span> cylinder_size</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.voxelization <span class="op">=</span> PillarVoxelNet(voxel_size, pc_range)</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cylinderlization <span class="op">=</span> CylinderNet(cylinder_size, cylinder_range)</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pillarview <span class="op">=</span> SingleView((in_channels <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">2</span>, num_filters, layer_nums, ds_layer_strides,</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>                                     ds_num_filters, kernel_size, <span class="st">'pillar'</span>, <span class="va">self</span>.voxel_size, <span class="va">self</span>.pc_range)</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cylinderview <span class="op">=</span> SingleView((in_channels <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">2</span>, num_filters, layer_nums, ds_layer_strides,</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>                                       ds_num_filters, kernel_size, <span class="st">'cylinder'</span>, <span class="va">self</span>.cylinder_size, <span class="va">self</span>.cylinder_range)</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ds_rate <span class="op">=</span> np.prod(np.array(ds_layer_strides))</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pointnet1 <span class="op">=</span> PointNet((in_channels <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> <span class="dv">2</span>, ds_num_filters[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.pointnet2 <span class="op">=</span> PointNet(ds_num_filters[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> <span class="dv">3</span>, out_channels)</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, points):</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>        dtype <span class="op">=</span> points.dtype</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>        pc_range <span class="op">=</span> torch.tensor(<span class="va">self</span>.pc_range, dtype<span class="op">=</span>dtype)</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> <span class="bu">reduce</span>(torch.logical_and, (points[:, <span class="dv">1</span>] <span class="op">&gt;=</span> pc_range[<span class="dv">0</span>],</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>                                          points[:, <span class="dv">1</span>] <span class="op">&lt;</span> pc_range[<span class="dv">3</span>],</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>                                          points[:, <span class="dv">2</span>] <span class="op">&gt;=</span> pc_range[<span class="dv">1</span>],</span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>                                          points[:, <span class="dv">2</span>] <span class="op">&lt;</span> pc_range[<span class="dv">4</span>],</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>                                          points[:, <span class="dv">3</span>] <span class="op">&gt;=</span> pc_range[<span class="dv">2</span>],</span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>                                          points[:, <span class="dv">3</span>] <span class="op">&lt;</span> pc_range[<span class="dv">5</span>]))</span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>        points <span class="op">=</span> points[mask]</span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>        pillar_feature, pillar_coords, pillar_inv, pillar_size <span class="op">=</span> <span class="va">self</span>.voxelization(</span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>            points)</span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a>        cylinder_feature, cylinder_coords, cylinder_inv, cylinder_size <span class="op">=</span> <span class="va">self</span>.cylinderlization(</span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a>            points)</span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a>        points_feature <span class="op">=</span> torch.cat((pillar_feature, cylinder_feature), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb40-54"><a href="#cb40-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-55"><a href="#cb40-55" aria-hidden="true" tabindex="-1"></a>        pillar_view <span class="op">=</span> <span class="va">self</span>.pillarview(</span>
<span id="cb40-56"><a href="#cb40-56" aria-hidden="true" tabindex="-1"></a>            points_feature, pillar_coords, pillar_inv, pillar_size)</span>
<span id="cb40-57"><a href="#cb40-57" aria-hidden="true" tabindex="-1"></a>        cylinder_view <span class="op">=</span> <span class="va">self</span>.cylinderview(</span>
<span id="cb40-58"><a href="#cb40-58" aria-hidden="true" tabindex="-1"></a>            points_feature, cylinder_coords, cylinder_inv, cylinder_size)</span>
<span id="cb40-59"><a href="#cb40-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-60"><a href="#cb40-60" aria-hidden="true" tabindex="-1"></a>        points_feature <span class="op">=</span> <span class="va">self</span>.pointnet1(points_feature)</span>
<span id="cb40-61"><a href="#cb40-61" aria-hidden="true" tabindex="-1"></a>        points_feature <span class="op">=</span> torch.cat(</span>
<span id="cb40-62"><a href="#cb40-62" aria-hidden="true" tabindex="-1"></a>            (points_feature, pillar_view, cylinder_view), dim<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb40-63"><a href="#cb40-63" aria-hidden="true" tabindex="-1"></a>        pillar_feature <span class="op">=</span> <span class="va">self</span>.pointnet2(points_feature)</span>
<span id="cb40-64"><a href="#cb40-64" aria-hidden="true" tabindex="-1"></a>        pillar_feature <span class="op">=</span> torch_scatter.scatter_max(</span>
<span id="cb40-65"><a href="#cb40-65" aria-hidden="true" tabindex="-1"></a>            pillar_feature, pillar_inv, dim<span class="op">=</span><span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb40-66"><a href="#cb40-66" aria-hidden="true" tabindex="-1"></a>        batch_size <span class="op">=</span> <span class="bu">len</span>(torch.unique(pillar_coords[:, <span class="dv">0</span>]))</span>
<span id="cb40-67"><a href="#cb40-67" aria-hidden="true" tabindex="-1"></a>        pillar_coords[:, <span class="dv">1</span>:] <span class="op">=</span> pillar_coords[:, <span class="dv">1</span>:] <span class="op">//</span> <span class="va">self</span>.ds_rate</span>
<span id="cb40-68"><a href="#cb40-68" aria-hidden="true" tabindex="-1"></a>        pillar_size <span class="op">=</span> pillar_size <span class="op">//</span> <span class="va">self</span>.ds_rate</span>
<span id="cb40-69"><a href="#cb40-69" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> spconv.pytorch.SparseConvTensor(</span>
<span id="cb40-70"><a href="#cb40-70" aria-hidden="true" tabindex="-1"></a>            pillar_feature, pillar_coords, pillar_size, batch_size)</span>
<span id="cb40-71"><a href="#cb40-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x.dense()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#mvffeaturenet"><code>MVFFeatureNet</code></a> class aggregates multiple views of the point cloud data by combining the already presented classes, <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarvoxelnet"><code>PillarVoxelNet</code></a> and <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#cylindernet"><code>CylinderNet</code></a>, to create a richer feature representation for 3D object detection tasks by using pillar-based and cylinder-based voxelization methods. The goal is to create a richer feature representation by leveraging the complementary strengths of these two methods:</p>
<ol type="1">
<li><p><strong>Pillar Voxelization</strong> (<a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarvoxelnet"><code>PillarVoxelNet</code></a>): Converts point cloud data into a pseudo-image representation by dividing the space into vertical columns (pillars). This method is efficient and captures the overall structure of the point cloud.</p></li>
<li><p><strong>Cylinder Voxelization</strong> (<a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#cylindernet"><code>CylinderNet</code></a>): Divides the point cloud into cylindrical segments, which can better capture radial features and angular information that might be missed by pillar-based methods.</p></li>
</ol>
<p>The <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#mvffeaturenet"><code>MVFFeatureNet</code></a> then processes these two types of voxelized features through separate convolutional pathways (<a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#singleview"><code>SingleView</code></a>) and integrates them using a series of PointNet modules to produce a final, unified feature representation.</p>
<ul>
<li><p><strong>Voxelization and Cylinderization</strong>: The point cloud data is first pre-processed by the <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#pillarvoxelnet"><code>PillarVoxelNet</code></a> and <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#cylindernet"><code>CylinderNet</code></a>, which convert the raw point cloud data into structured formats that are easier to process with convolutional layers.</p></li>
<li><p><strong>SingleView Processing</strong>: Each view (pillar and cylinder) is processed independently using the <a href="https://AIR-UFG.github.io/pillarnext_explained/model_readers.html#singleview"><code>SingleView</code></a> class, which applies a series of convolutional layers to extract features. These features are later merged to provide a multi-view representation of the data.</p></li>
<li><p><strong>PointNet</strong>: This module processes the combined features from both views. PointNet is well-suited for handling irregular point cloud data and is used here to further refine the feature representation.</p></li>
<li><p><strong>Sparse Convolution Tensor</strong>: Finally, the processed features are packed into a sparse tensor format using <code>spconv.pytorch.SparseConvTensor</code> and returned as the output of the network.</p></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/AIR-UFG\.github\.io\/pillarnext_explained");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/AIR-UFG/pillarnext_explained/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>